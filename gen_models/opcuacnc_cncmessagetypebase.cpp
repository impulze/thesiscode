/******************************************************************************
** opcuacnc_cncmessagetypebase.cpp
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.5.0, using C++ OPC UA SDK 1.5.0 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2016 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.5
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.5, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.5/
**
** Project: C++ OPC Server SDK information model for namespace http://opcfoundation.org/UA/CNC/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** Created: 19.08.2016
**
******************************************************************************/

#include "opcuacnc_cncmessagetypebase.h"
#include "opcuacnc_cncmessagetype.h"
#include "uagenericnodes.h"
#include "nodemanagerroot.h"
#include "eventmanageruanode.h"
#include "methodhandleuanode.h"
#include "instancefactory.h"
#include "opcuacnc_nodemanagercnc.h"

// Namespace for the UA information model http://opcfoundation.org/UA/CNC/
namespace OpcUaCnc {

bool CncMessageTypeBase::s_typeNodesCreated = false;
std::map<OpcUa_UInt32, OpcUa_UInt32> CncMessageTypeBase::s_CncMessageTypeDataFields;

/** Constructs an instance of the CncMessageType condition type using an instance declaration node as base.
*/
CncMessageTypeBase::CncMessageTypeBase(const UaNodeId& nodeId, UaObject* pInstanceDeclarationObject, NodeManagerConfig* pNodeConfig, const UaNodeId& sourceNode, const UaString& sourceName, UaMutexRefCounted* pSharedMutex)
: OpcUa::ConditionType(nodeId, pInstanceDeclarationObject, pNodeConfig, sourceNode, sourceName, pSharedMutex)
{
    createChildren();
}

/** Constructs an instance of the CncMessageType condition type.
*/
CncMessageTypeBase::CncMessageTypeBase(const UaNodeId& nodeId, const UaString& name, OpcUa_UInt16 browseNameNameSpaceIndex, NodeManagerConfig* pNodeConfig, const UaNodeId& sourceNode, const UaString& sourceName, UaMutexRefCounted* pSharedMutex)
: OpcUa::ConditionType(nodeId, name, browseNameNameSpaceIndex, pNodeConfig, sourceNode, sourceName, pSharedMutex)
{
    createChildren();
}

/**  Constructs an instance of the class CncMessageTypeBase with all components.
*/
CncMessageTypeBase::CncMessageTypeBase(
    UaBase::Object*    pBaseNode,    //!< [in] The "tree" of nodes that specifies the attributes of the instance and its children.
    XmlUaNodeFactoryManager* pFactory, //!< [in] The factory to create the children.
    NodeManagerConfig* pNodeConfig,  //!< [in] Interface pointer to the NodeManagerConfig interface used to add and delete node and references in the address space.
    UaMutexRefCounted* pSharedMutex) //!< [in] Shared mutex object used to synchronize access to the variable. Can be NULL if no shared mutex is provided.
: OpcUa::ConditionType(pBaseNode, pFactory, pNodeConfig, pSharedMutex)
{
    initialize();

}

void CncMessageTypeBase::initialize()
{
    OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
    m_EventTypeId.setNodeId(OpcUaCncId_CncMessageType, nsTypeIdx);

    UaVariant   eventTypeValue;
    UaDataValue eventTypeDataValue;
    eventTypeValue.setNodeId(m_EventTypeId);
    eventTypeDataValue.setValue(eventTypeValue, OpcUa_True, OpcUa_True);
    m_pEventTypeProperty->setValue(NULL, eventTypeDataValue, OpcUa_False);

    if ( s_typeNodesCreated == false )
    {
        createTypes();
    }
}

void CncMessageTypeBase::createChildren()
{
    initialize();

}

/** Destroys the CncMessageType object
*/
CncMessageTypeBase::~CncMessageTypeBase()
{
}

/** Create the related type nodes
*/
void CncMessageTypeBase::createTypes()
{
    if ( s_typeNodesCreated == false )
    {
        s_typeNodesCreated = true;

        // Check if supertype is already created
        OpcUa::ConditionType::createTypes();

        registerEventFields();

        UaStatus      addStatus;
        NodeManagerRoot* pNodeManagerRoot = NodeManagerRoot::CreateRootNodeManager();
        OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
        OpcUa_Int16 nsSuperTypeIdx = NodeManagerRoot::getTypeNamespace();
        NodeManagerConfig* pTypeNodeConfig = pNodeManagerRoot->getNodeManagerByNamespace(nsTypeIdx)->getNodeManagerConfig();

        OpcUa::GenericObjectType* pObjectType;
        pObjectType = new OpcUa::GenericObjectType(
            UaNodeId(OpcUaCncId_CncMessageType, nsTypeIdx),
            UaQualifiedName("CncMessageType", nsTypeIdx),
            UaLocalizedText("", "CncMessageType"),
            UaLocalizedText("", ""),
            OpcUa_False,
            &CncMessageType::clearStaticMembers);
        addStatus = pTypeNodeConfig->addNodeAndReference(UaNodeId(OpcUaId_ConditionType, nsSuperTypeIdx), pObjectType, OpcUaId_HasSubtype);
        UA_ASSERT(addStatus.isGood());

    }
}

/** Clear the static members of the class
*/
void CncMessageTypeBase::clearStaticMembers()
{
    s_typeNodesCreated = false;

    s_CncMessageTypeDataFields.clear();
}

/** Returns the type definition NodeId for the CncMessageType
*/
UaNodeId CncMessageTypeBase::typeDefinitionId() const
{
    UaNodeId ret(OpcUaCncId_CncMessageType, NodeManagerCNC::getTypeNamespace());
    return ret;
}

/** Registers all event type fields with the EventManagerBase.
 */
void CncMessageTypeBase::registerEventFields()
{
    // Register event type
    OpcUa_Int16 nsSuperTypeIdx = NodeManagerRoot::getTypeNamespace();
    OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
    EventManagerBase::registerEventType(UaNodeId(OpcUaId_ConditionType, nsSuperTypeIdx), UaNodeId(OpcUaCncId_CncMessageType, nsTypeIdx));
}

/** Registers optional event fields with the EventManagerBase.
 */
OpcUa_UInt32 CncMessageTypeBase::registerOptionalEventFields(const UaString& fieldName)
{
    OpcUa_UInt32 ret = 0;
    OpcUa_UInt32 externalIndex = EventManagerBase::registerEventField(fieldName);
    std::map<OpcUa_UInt32, OpcUa_UInt32>::iterator it;

    it = s_CncMessageTypeDataFields.find(externalIndex);
    if ( it != s_CncMessageTypeDataFields.end() )
    {
        return it->second;
    }

    for ( it=s_CncMessageTypeDataFields.begin(); it!=s_CncMessageTypeDataFields.end(); it++ )
    {
        if ( ret < it->second )
        {
            ret = it->second;
        }
    }
    ret++;

    s_CncMessageTypeDataFields[externalIndex] = ret;

    return ret;
}

/** Get the field value for the passed index.
 *  @param index The index of the selected field.
 *  @param pSession The session context for the method call.
 *  @param data The data for the selected field.
 */
void CncMessageTypeBase::getFieldData(OpcUa_UInt32 index, Session* pSession, OpcUa_Variant& data)
{
    // Try to find the field index
    std::map<OpcUa_UInt32, OpcUa_UInt32>::iterator it;
    it = s_CncMessageTypeDataFields.find(index);

    if ( it == s_CncMessageTypeDataFields.end()  )
    {
        ConditionTypeBase::getFieldData(index, pSession, data);
        return;
    }

    getCncMessageTypeOptionalFieldData(it->second, pSession, data);
}

/** Clears the event field data after event processing
*/
void CncMessageTypeBase::clearFieldData()
{
    m_FieldValues.clear();

    ConditionTypeBase::clearFieldData();
}

/** Creates a new branch from the current state and adds the branch to a list managed by the condition object.
 *  ConditionType::getBranch() and ConditionType::deleteBranch() can be used to access or to delete the branch.
*/
UaNodeId CncMessageTypeBase::createBranch()
{
    UaNodeId ret;
    CncMessageTypeData* pBranch = new CncMessageTypeData;
    pBranch->initializeAsBranch(this);
    addBranch(pBranch, pBranch->getBranchId());
    return pBranch->getBranchId();
}



/** Send event with current event field data to the subscribed clients.
* After setting the changed states of the event this method is used to trigger the event notification that
* contains the snapshot of the new state of the condition.
*/
UaStatus CncMessageTypeBase::triggerEvent(
    const UaDateTime&   time,        /**< [in] Time provides the time the Event occurred. This value is set as close to the event
                                               generator as possible. It often comes from the underlying system or device. */
    const UaDateTime&   receiveTime, /**< [in] ReceiveTime provides the time the OPC UA Server received the Event from the
                                               underlying device or another Server. */
    const UaByteString& userEventId) /**< [in] The server is responsible for generating a unique EventId for every event sent
                                               to the client. The SDK uses this parameter userEventId as part of the EventId but adds a unique
                                               part. The EventId is provided by the client in calls back to the server like in an alarm
                                               acknowledgement. The user specific part can be extracted from the EventId provided by the client
                                               by using EventManagerBase::getUserEventId(). */
{
    UaMutexLocker lock(m_pSharedMutex);
    clearFieldData();

    m_Time.setDateTime(time);
    m_ReceiveTime.setDateTime(receiveTime);

    // Create a unique EventId sent to the client and include the one passed to this function
    UaByteString clientEventId;
    EventManagerUaNode::buildEventId(userEventId, clientEventId);
    m_EventId.setByteString(clientEventId, OpcUa_True);

    return sendEvent(this);
}

/** Get the field value for the passed index for optional fields of the CncMessageType.
 *  This function must be overwritten by derived classes to provide the optional fields registered
 *  with CncMessageTypeData::registerOptionalEventFields.
 *  @param index The index of the selected field.
 *  @param pSession The session context for the method call.
 *  @param data The data for the selected field.
 */
void CncMessageTypeBase::getCncMessageTypeOptionalFieldData(OpcUa_UInt32, Session*, OpcUa_Variant& data)
{
    OpcUa_Variant_Initialize(&data);
}
/** Applies the NodeAccessInfo set at the CncMessageTypeBase and its children. */
void CncMessageTypeBase::useAccessInfoFromType()
{
    OpcUa::ConditionType::useAccessInfoFromType();

    // instance node
    OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
    UaNode *pTypeNode = NodeManagerRoot::CreateRootNodeManager()->getNode(UaNodeId(OpcUaCncId_CncMessageType, nsTypeIdx));
    if (pTypeNode)
    {
        useAccessInfoFrom(pTypeNode);
        pTypeNode->releaseReference();
    }
}

/** Uses the NodeAccessInfo of pOther and its children. */
void CncMessageTypeBase::useAccessInfoFromInstance(CncMessageTypeBase *pOther)
{
    OpcUa::ConditionType::useAccessInfoFromInstance(pOther);
}


// #####################################################################################################
// #####################################################################################################

/** Constructs an CncMessageTypeData object
*/
CncMessageTypeData::CncMessageTypeData()
: OpcUa::ConditionTypeData()
{
    initialize();
}

/** Initialize the CncMessageTypeData object
*/
void CncMessageTypeData::initialize()
{
    OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
    m_EventTypeId.setNodeId(OpcUaCncId_CncMessageType, nsTypeIdx);

    // Create a unique EventId sent to the client
    UaByteString clientEventId;
    EventManagerUaNode::buildEventId(UaByteString(), clientEventId);
    m_EventId.setByteString(clientEventId, OpcUa_True);

    if ( CncMessageTypeBase::s_typeNodesCreated == false )
    {
        CncMessageType::createTypes();
    }
}

/** Destroys the CncMessageTypeData object
*/
CncMessageTypeData::~CncMessageTypeData()
{
}

/** This method is used to initializes the CncMessageTypeData object with event data
 *  from a condition object to create a branch of this condition object. The method creates a unique BranchId.
 *  EventManagerBase::fireEvent() is used send the intial branch state and status updates for the branch to
 *  the client(s). It is necessary to update the timestamps and the EventId for every update sent to the client(s).
 *  @param pCondition The condition object .
 */
void CncMessageTypeData::initializeAsBranch(CncMessageTypeBase* pCondition)
{
    OpcUa::ConditionTypeData::initializeAsBranch(pCondition);

}

/** This method is used to initializes the CncMessageTypeData object with event data
 *  from another condition data object to create a branch of this condition data object. The method creates a unique BranchId.
 *  EventManagerBase::fireEvent() is used to send the intial branch state and status updates for the branch to
 *  the client(s). It is necessary to update the timestamps and the EventId for every update sent to the client(s).
 *  @param pConditionData The condition data object .
 */
void CncMessageTypeData::initializeAsBranch(CncMessageTypeData* pConditionData)
{
    OpcUa::ConditionTypeData::initializeAsBranch(pConditionData);

}

/** Get the field value for the passed index.
 *  @param index The index of the selected field.
 *  @param pSession The session context for the method call.
 *  @param data The data for the selected field.
 */
void CncMessageTypeData::getFieldData(OpcUa_UInt32 index, Session* pSession, OpcUa_Variant& data)
{
    // Try to find the field index
    std::map<OpcUa_UInt32, OpcUa_UInt32>::iterator it;
    it = CncMessageTypeBase::s_CncMessageTypeDataFields.find(index);

    if ( it == CncMessageTypeBase::s_CncMessageTypeDataFields.end()  )
    {
        ConditionTypeData::getFieldData(index, pSession, data);
        return;
    }

    OpcUa_Variant_Clear(&data);
}



} // End namespace for the UA information model http://opcfoundation.org/UA/CNC/

