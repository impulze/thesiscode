/******************************************************************************
** opcuacnc_cncpositionvariabletype.cpp
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.5.0, using C++ OPC UA SDK 1.5.0 template (version 4)
**
**     Changes to this file may cause incorrect behavior and will be lost if
**     the code is regenerated.
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2016 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.5
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.5, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.5/
**
** Project: C++ OPC Server SDK information model for namespace http://opcfoundation.org/UA/CNC/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** Created: 19.08.2016
**
******************************************************************************/

#include "opcuacnc_cncpositionvariabletype.h"
#include "uagenericnodes.h"
#include "nodemanagerroot.h"
#include "instancefactory.h"
#include "opcuacnc_nodemanagercnc.h"


// Namespace for the UA information model http://opcfoundation.org/UA/CNC/
namespace OpcUaCnc {

bool CncPositionVariableType::s_typeNodesCreated = false;
OpcUa::BaseDataVariableType* CncPositionVariableType::s_pActPos = NULL;
OpcUa::BaseDataVariableType* CncPositionVariableType::s_pCmdPos = NULL;
OpcUa::PropertyType* CncPositionVariableType::s_pEngineeringUnits = NULL;
OpcUa::PropertyType* CncPositionVariableType::s_pEURange = NULL;
OpcUa::BaseDataVariableType* CncPositionVariableType::s_pRemDist = NULL;

/** Constructs an instance of the class CncPositionVariableType based on an instance declaration variable.

 This constructor is used if the variable is created based on an instance declaration of an object or variable type. Since the only difference between the
 instance declaration variable and the instance variable are the NodeId and the Value, the pointer to the instance declaration node is used to get the attribute
 values other than the attributes NodeId and Value from the instance declaration node.<br>
 The variable is reference counted and can not be deleted directly. The reference counter is set to one after the variable is created.
 If the variable was successfully added to a NodeManager using the methods NodeManagerConfig::addUaNode or NodeManagerConfig::addNodeAndReference the
 NodeManager will release this reference during shut down. If the variable was not added to a NodeManager, it must be deleted using the releaseReference
 method. If the interface pointer is used in other places, the availability of the variable must be ensured by incrementing the reference counter with
 addReference when the pointer is stored somewhere and decremented with releaseReference if the interface pointer is not longer needed.
*/
CncPositionVariableType::CncPositionVariableType(
    UaNode*            pParentNode,  //!< [in] Parent node of the new variable
    UaVariable*        pInstanceDeclarationVariable, //!< [in] UaVariable interface of the instance declaration node used to provide attribute values other than NodeId and Value
    NodeManagerConfig* pNodeConfig,  //!< [in] Interface pointer to the NodeManagerConfig interface used to add and delete node and references in the address space
    UaMutexRefCounted* pSharedMutex) //!< [in] Shared mutex object used to synchronize access to the variable. Can be NULL if no shared mutex is provided
: OpcUa::BaseDataVariableType(pParentNode, pInstanceDeclarationVariable, pNodeConfig, pSharedMutex)
{
    initialize(pNodeConfig);
}

/** Constructs an instance of the class CncPositionVariableType with the passed attribute values.

 This constructor is used if the variable is not created based on an instance declaration. It defines the name, nodeId, initial value and access level
 of the variable. Additional language specific names and other attribute values can be set with set methods provided by the class.
 The variable is reference counted and can not be deleted directly. The reference counter is set to one after the variable is created.
 If the variable was successfully added to a NodeManager using the methods NodeManagerConfig::addUaNode or NodeManagerConfig::addNodeAndReference the
 NodeManager will release this reference during shut down. If the variable was not added to a NodeManager, it must be deleted using the releaseReference
 method. If the interface pointer is used in other places, the availability of the variable must be ensured by incrementing the reference counter with
 addReference when the pointer is stored somewhere and decremented with releaseReference if the interface pointer is not longer needed.
*/
CncPositionVariableType::CncPositionVariableType(
    const UaNodeId&    nodeId,       //!< [in] NodeId of the new variable
    const UaString&    name,         //!< [in] Name of the new variable. Used as browse name and also as display name if no additional language specific names are set.
    OpcUa_UInt16       browseNameNameSpaceIndex, //!< [in] Namespace index used for the browse name
    const UaVariant&   initialValue, //!< [in] Initial value for the Variable
    OpcUa_Byte         accessLevel,  //!< [in] Access level for the Variable
    NodeManagerConfig* pNodeConfig,  //!< [in] Interface pointer to the NodeManagerConfig interface used to add and delete node and references in the address space
    UaMutexRefCounted* pSharedMutex) //!< [in] Shared mutex object used to synchronize access to the variable. Can be NULL if no shared mutex is provided
: OpcUa::BaseDataVariableType(nodeId, name, browseNameNameSpaceIndex, initialValue, accessLevel, pNodeConfig, pSharedMutex)
{
    initialize(pNodeConfig);
}

/**  Constructs an instance of the class CncPositionVariableType with all components
*/
CncPositionVariableType::CncPositionVariableType(
    UaBase::Variable*  pBaseNode,    //!< [in] The "tree" of nodes that specifies the attributes of the instance and its children
    XmlUaNodeFactoryManager* pFactory, //!< [in] The factory to create the children
    NodeManagerConfig* pNodeConfig,  //!< [in] Interface pointer to the NodeManagerConfig interface used to add and delete node and references in the address space
    UaMutexRefCounted* pSharedMutex) //!< [in] Shared mutex object used to synchronize access to the variable. Can be NULL if no shared mutex is provided
: OpcUa::BaseDataVariableType(pBaseNode, pFactory, pNodeConfig, pSharedMutex)
{
    UaStatus      addStatus;

    if ( s_typeNodesCreated == false )
    {
        createTypes();
    }

    m_pActPos = NULL;
    m_pCmdPos = NULL;
    m_pEngineeringUnits = NULL;
    m_pEURange = NULL;
    m_pRemDist = NULL;

    std::list<UaBase::BaseNode*> lstReferencedNodes = pBaseNode->hierarchicallyReferencedNodes();
    for (std::list<UaBase::BaseNode*>::const_iterator it = lstReferencedNodes.begin(); it != lstReferencedNodes.end(); it++)
    {
        UaBase::BaseNode *pChild = *it;
        UaBase::Variable *pVariable = (UaBase::Variable*) pChild;
        if (pChild->browseName() == UaQualifiedName("ActPos", OpcUaCnc::NodeManagerCNC::getTypeNamespace()))
        {
            if (!m_pActPos)
            {
                m_pActPos = (OpcUa::BaseDataVariableType*) pFactory->createVariable((UaBase::Variable*)*it, pNodeConfig, pSharedMutex);
                if (!pVariable->modellingRuleId().isNull())
                {
                    m_pActPos->setModellingRuleId(pVariable->modellingRuleId());
                }
                addStatus = pNodeConfig->addNodeAndReference(this, m_pActPos, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
            }
        }
        else if (pChild->browseName() == UaQualifiedName("CmdPos", OpcUaCnc::NodeManagerCNC::getTypeNamespace()))
        {
            if (!m_pCmdPos)
            {
                m_pCmdPos = (OpcUa::BaseDataVariableType*) pFactory->createVariable((UaBase::Variable*)*it, pNodeConfig, pSharedMutex);
                if (!pVariable->modellingRuleId().isNull())
                {
                    m_pCmdPos->setModellingRuleId(pVariable->modellingRuleId());
                }
                addStatus = pNodeConfig->addNodeAndReference(this, m_pCmdPos, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
            }
        }
        else if (pChild->browseName() == UaQualifiedName("EngineeringUnits", 0))
        {
            if (!m_pEngineeringUnits)
            {
                m_pEngineeringUnits = (OpcUa::PropertyType*) pFactory->createVariable((UaBase::Variable*)*it, pNodeConfig, pSharedMutex);
                if (!pVariable->modellingRuleId().isNull())
                {
                    m_pEngineeringUnits->setModellingRuleId(pVariable->modellingRuleId());
                }
                addStatus = pNodeConfig->addNodeAndReference(this, m_pEngineeringUnits, OpcUaId_HasProperty);
                UA_ASSERT(addStatus.isGood());
            }
        }
        else if (pChild->browseName() == UaQualifiedName("EURange", 0))
        {
            if (!m_pEURange)
            {
                m_pEURange = (OpcUa::PropertyType*) pFactory->createVariable((UaBase::Variable*)*it, pNodeConfig, pSharedMutex);
                if (!pVariable->modellingRuleId().isNull())
                {
                    m_pEURange->setModellingRuleId(pVariable->modellingRuleId());
                }
                addStatus = pNodeConfig->addNodeAndReference(this, m_pEURange, OpcUaId_HasProperty);
                UA_ASSERT(addStatus.isGood());
            }
        }
        else if (pChild->browseName() == UaQualifiedName("RemDist", OpcUaCnc::NodeManagerCNC::getTypeNamespace()))
        {
            if (!m_pRemDist)
            {
                m_pRemDist = (OpcUa::BaseDataVariableType*) pFactory->createVariable((UaBase::Variable*)*it, pNodeConfig, pSharedMutex);
                if (!pVariable->modellingRuleId().isNull())
                {
                    m_pRemDist->setModellingRuleId(pVariable->modellingRuleId());
                }
                addStatus = pNodeConfig->addNodeAndReference(this, m_pRemDist, OpcUaId_HasComponent);
                UA_ASSERT(addStatus.isGood());
            }
        }
    }
    UA_ASSERT(m_pActPos);
    UA_ASSERT(m_pCmdPos);
    UA_ASSERT(m_pEngineeringUnits);
    UA_ASSERT(m_pEURange);
    UA_ASSERT(m_pRemDist);
}

/** Initialize the variable with all member nodes
*/
void CncPositionVariableType::initialize(NodeManagerConfig* pNodeConfig)
{
    UaStatus      addStatus;

    if ( s_typeNodesCreated == false )
    {
        createTypes();
    }

    // Double variable ActPos
    m_pActPos = new OpcUa::BaseDataVariableType(this, s_pActPos, pNodeConfig, getSharedMutex());
    addStatus = pNodeConfig->addNodeAndReference(this, m_pActPos, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // Double variable CmdPos
    m_pCmdPos = new OpcUa::BaseDataVariableType(this, s_pCmdPos, pNodeConfig, getSharedMutex());
    addStatus = pNodeConfig->addNodeAndReference(this, m_pCmdPos, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());

    // EUInformation variable EngineeringUnits
    m_pEngineeringUnits = new OpcUa::PropertyType(this, s_pEngineeringUnits, pNodeConfig, getSharedMutex());
    addStatus = pNodeConfig->addNodeAndReference(this, m_pEngineeringUnits, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());
    m_pEngineeringUnits->setDataType(UaNodeId(OpcUaId_EUInformation));

    // Range variable EURange
    m_pEURange = new OpcUa::PropertyType(this, s_pEURange, pNodeConfig, getSharedMutex());
    addStatus = pNodeConfig->addNodeAndReference(this, m_pEURange, OpcUaId_HasProperty);
    UA_ASSERT(addStatus.isGood());
    m_pEURange->setDataType(UaNodeId(OpcUaId_Range));

    // Double variable RemDist
    m_pRemDist = new OpcUa::BaseDataVariableType(this, s_pRemDist, pNodeConfig, getSharedMutex());
    addStatus = pNodeConfig->addNodeAndReference(this, m_pRemDist, OpcUaId_HasComponent);
    UA_ASSERT(addStatus.isGood());
}

/** Destroys the CncPositionVariableType object
*
* The destructor is protected since the object is reference counted. It is not possible to delete the object directly.
*
* If the node was added successfully to a NodeManager, it can only be deleted by deleting the node from the NodeManager.
* If the node was not added to a NodeManager or adding the node failed, the node can be deleted by releasing the reference to the node.
* In addition potential children should be deleted before releasing the reference. The two variations are shown in the following sample code.
* @code
* CncPositionVariableType* pCncPositionVariableType;
* MyNodeManager*  pNodeManager;
*
* // Delete children and release reference if the node was not added to a NodeManager
* pCncPositionVariableType->deleteAllChildren(pNodeManager);
* pCncPositionVariableType->releaseReference();
*
* // Delete the node from the NodeManager after it was added to the NodeManager
* pNodeManager->deleteUaNode(pCncPositionVariableType, OpcUa_True, OpcUa_True, OpcUa_True);
* @endcode
*/
CncPositionVariableType::~CncPositionVariableType()
{
}

/** Create the related type nodes
*/
void CncPositionVariableType::createTypes()
{
    if ( s_typeNodesCreated == false )
    {
        OpcUa::BaseDataVariableType::createTypes();
        s_typeNodesCreated = true;
        UaStatus      addStatus;
        UaVariant     defaultValue;
        NodeManagerRoot* pNodeManagerRoot = NodeManagerRoot::CreateRootNodeManager();
        OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
        NodeManagerConfig* pTypeNodeConfig = pNodeManagerRoot->getNodeManagerByNamespace(nsTypeIdx)->getNodeManagerConfig();

        UaVariant                   nullValue;
        OpcUa::GenericVariableType* pVariableType;
        pVariableType = new OpcUa::GenericVariableType(
            UaNodeId(OpcUaCncId_CncPositionVariableType, nsTypeIdx),
            UaQualifiedName("CncPositionVariableType", nsTypeIdx),
            UaLocalizedText("", "CncPositionVariableType"),
            UaLocalizedText("", ""),
            nullValue,
            UaNodeId(OpcUaCncId_CncPositionType, OpcUaCnc::NodeManagerCNC::getTypeNamespace()),
            -2,
            OpcUa_False,
            &clearStaticMembers);
        addStatus = pTypeNodeConfig->addNodeAndReference(UaNodeId(OpcUaId_BaseDataVariableType, NodeManagerRoot::getTypeNamespace()), pVariableType, OpcUaId_HasSubtype);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable ActPos
        defaultValue.setDouble(0.0);
        s_pActPos = new OpcUa::BaseDataVariableType(UaNodeId(OpcUaCncId_CncPositionVariableType_ActPos, nsTypeIdx), "ActPos", OpcUaCnc::NodeManagerCNC::getTypeNamespace(), defaultValue, 1, pTypeNodeConfig);
        s_pActPos->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pActPos->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pVariableType, s_pActPos, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable CmdPos
        defaultValue.setDouble(0.0);
        s_pCmdPos = new OpcUa::BaseDataVariableType(UaNodeId(OpcUaCncId_CncPositionVariableType_CmdPos, nsTypeIdx), "CmdPos", OpcUaCnc::NodeManagerCNC::getTypeNamespace(), defaultValue, 3, pTypeNodeConfig);
        s_pCmdPos->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pCmdPos->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pVariableType, s_pCmdPos, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable EngineeringUnits
        UaEUInformation valEngineeringUnits;
        valEngineeringUnits.toVariant(defaultValue);
        s_pEngineeringUnits = new OpcUa::PropertyType(UaNodeId(OpcUaCncId_CncPositionVariableType_EngineeringUnits, nsTypeIdx), "EngineeringUnits", NodeManagerRoot::getTypeNamespace(), defaultValue, 1, pTypeNodeConfig);
        s_pEngineeringUnits->setDataType(UaNodeId(OpcUaId_EUInformation));
        s_pEngineeringUnits->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pEngineeringUnits->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pVariableType, s_pEngineeringUnits, OpcUaId_HasProperty);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable EURange
        UaRange valEURange;
        valEURange.toVariant(defaultValue);
        s_pEURange = new OpcUa::PropertyType(UaNodeId(OpcUaCncId_CncPositionVariableType_EURange, nsTypeIdx), "EURange", NodeManagerRoot::getTypeNamespace(), defaultValue, 1, pTypeNodeConfig);
        s_pEURange->setDataType(UaNodeId(OpcUaId_Range));
        s_pEURange->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pEURange->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pVariableType, s_pEURange, OpcUaId_HasProperty);
        UA_ASSERT(addStatus.isGood());

        // Mandatory variable RemDist
        defaultValue.setDouble(0.0);
        s_pRemDist = new OpcUa::BaseDataVariableType(UaNodeId(OpcUaCncId_CncPositionVariableType_RemDist, nsTypeIdx), "RemDist", OpcUaCnc::NodeManagerCNC::getTypeNamespace(), defaultValue, 1, pTypeNodeConfig);
        s_pRemDist->setModellingRuleId(OpcUaId_ModellingRule_Mandatory);
        s_pRemDist->setValueRank(-1);
        addStatus = pTypeNodeConfig->addNodeAndReference(pVariableType, s_pRemDist, OpcUaId_HasComponent);
        UA_ASSERT(addStatus.isGood());

    }
}

/** Clear the static members of the class
*/
void CncPositionVariableType::clearStaticMembers()
{
    s_typeNodesCreated = false;

    s_pActPos = NULL;
    s_pCmdPos = NULL;
    s_pEngineeringUnits = NULL;
    s_pEURange = NULL;
    s_pRemDist = NULL;
}

/** Returns the type definition NodeId for the CncPositionVariableType
*/
UaNodeId CncPositionVariableType::typeDefinitionId() const
{
    UaNodeId ret(OpcUaCncId_CncPositionVariableType, NodeManagerCNC::getTypeNamespace());
    return ret;
}

/**
 *  Sets the ActPos value
 */
void CncPositionVariableType::setActPos(OpcUa_Double ActPos)
{
    UaVariant value;
    value.setDouble(ActPos);
    UaDataValue dataValue;
    dataValue.setValue(value, OpcUa_True, OpcUa_True);
    m_pActPos->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of ActPos
 */
OpcUa_Double CncPositionVariableType::getActPos() const
{
    UaVariant defaultValue;
    OpcUa_Double ret = 0;
    UaDataValue dataValue(m_pActPos->value(NULL));
    defaultValue = *dataValue.value();
    defaultValue.toDouble(ret);
    return ret;
}


/**
 *  Sets the CmdPos value
 */
void CncPositionVariableType::setCmdPos(OpcUa_Double CmdPos)
{
    UaVariant value;
    value.setDouble(CmdPos);
    UaDataValue dataValue;
    dataValue.setValue(value, OpcUa_True, OpcUa_True);
    m_pCmdPos->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of CmdPos
 */
OpcUa_Double CncPositionVariableType::getCmdPos() const
{
    UaVariant defaultValue;
    OpcUa_Double ret = 0;
    UaDataValue dataValue(m_pCmdPos->value(NULL));
    defaultValue = *dataValue.value();
    defaultValue.toDouble(ret);
    return ret;
}


/**
 *  Sets the EngineeringUnits value
 */
void CncPositionVariableType::setEngineeringUnits(const UaEUInformation& EngineeringUnits)
{
    UaDataValue dataValue;
    EngineeringUnits.toDataValue(dataValue, OpcUa_True);
    m_pEngineeringUnits->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of EngineeringUnits
 */
UaEUInformation CncPositionVariableType::getEngineeringUnits() const
{
    UaEUInformation ret;
    UaDataValue dataValue(m_pEngineeringUnits->value(NULL));
    UaExtensionObject tmpExtensionObject;
    UaVariant(*dataValue.value()).toExtensionObject(tmpExtensionObject);
    ret.setEUInformation(tmpExtensionObject, OpcUa_True);
    return ret;
}


/**
 *  Sets the EURange value
 */
void CncPositionVariableType::setEURange(const UaRange& EURange)
{
    UaDataValue dataValue;
    EURange.toDataValue(dataValue, OpcUa_True);
    m_pEURange->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of EURange
 */
UaRange CncPositionVariableType::getEURange() const
{
    UaRange ret;
    UaDataValue dataValue(m_pEURange->value(NULL));
    UaExtensionObject tmpExtensionObject;
    UaVariant(*dataValue.value()).toExtensionObject(tmpExtensionObject);
    ret.setRange(tmpExtensionObject, OpcUa_True);
    return ret;
}


/**
 *  Sets the RemDist value
 */
void CncPositionVariableType::setRemDist(OpcUa_Double RemDist)
{
    UaVariant value;
    value.setDouble(RemDist);
    UaDataValue dataValue;
    dataValue.setValue(value, OpcUa_True, OpcUa_True);
    m_pRemDist->setValue(NULL, dataValue, OpcUa_False);
}

/**
 *  Returns the value of RemDist
 */
OpcUa_Double CncPositionVariableType::getRemDist() const
{
    UaVariant defaultValue;
    OpcUa_Double ret = 0;
    UaDataValue dataValue(m_pRemDist->value(NULL));
    defaultValue = *dataValue.value();
    defaultValue.toDouble(ret);
    return ret;
}

/** Returns the ActPos node.
 */
OpcUa::BaseDataVariableType* CncPositionVariableType::getActPosNode()
{
    return m_pActPos;
}

/** Returns the ActPos node.
 */
const OpcUa::BaseDataVariableType* CncPositionVariableType::getActPosNode() const
{
    return m_pActPos;
}

/** Returns the CmdPos node.
 */
OpcUa::BaseDataVariableType* CncPositionVariableType::getCmdPosNode()
{
    return m_pCmdPos;
}

/** Returns the CmdPos node.
 */
const OpcUa::BaseDataVariableType* CncPositionVariableType::getCmdPosNode() const
{
    return m_pCmdPos;
}

/** Returns the EngineeringUnits node.
 */
OpcUa::PropertyType* CncPositionVariableType::getEngineeringUnitsNode()
{
    return m_pEngineeringUnits;
}

/** Returns the EngineeringUnits node.
 */
const OpcUa::PropertyType* CncPositionVariableType::getEngineeringUnitsNode() const
{
    return m_pEngineeringUnits;
}

/** Returns the EURange node.
 */
OpcUa::PropertyType* CncPositionVariableType::getEURangeNode()
{
    return m_pEURange;
}

/** Returns the EURange node.
 */
const OpcUa::PropertyType* CncPositionVariableType::getEURangeNode() const
{
    return m_pEURange;
}

/** Returns the RemDist node.
 */
OpcUa::BaseDataVariableType* CncPositionVariableType::getRemDistNode()
{
    return m_pRemDist;
}

/** Returns the RemDist node.
 */
const OpcUa::BaseDataVariableType* CncPositionVariableType::getRemDistNode() const
{
    return m_pRemDist;
}


/** Applies the NodeAccessInfo set at the Base and its children. */
void CncPositionVariableType::useAccessInfoFromType()
{
    // instance node
    OpcUa_Int16 nsTypeIdx = NodeManagerCNC::getTypeNamespace();
    UaNode *pTypeNode = NodeManagerRoot::CreateRootNodeManager()->getNode(UaNodeId(OpcUaCncId_CncPositionVariableType, nsTypeIdx));
    if (pTypeNode)
    {
        useAccessInfoFrom(pTypeNode);
        pTypeNode->releaseReference();
    }

    // children
    m_pActPos->useAccessInfoFromInstance(s_pActPos);
    m_pCmdPos->useAccessInfoFromInstance(s_pCmdPos);
    m_pEngineeringUnits->useAccessInfoFromInstance(s_pEngineeringUnits);
    m_pEURange->useAccessInfoFromInstance(s_pEURange);
    m_pRemDist->useAccessInfoFromInstance(s_pRemDist);
}

/** Uses the NodeAccessInfo of pOther and its children. */
void CncPositionVariableType::useAccessInfoFromInstance(CncPositionVariableType *pOther)
{
    OpcUa::BaseDataVariableType::useAccessInfoFromInstance(pOther);

    // children
    m_pActPos->useAccessInfoFromInstance(pOther->m_pActPos);
    m_pCmdPos->useAccessInfoFromInstance(pOther->m_pCmdPos);
    m_pEngineeringUnits->useAccessInfoFromInstance(pOther->m_pEngineeringUnits);
    m_pEURange->useAccessInfoFromInstance(pOther->m_pEURange);
    m_pRemDist->useAccessInfoFromInstance(pOther->m_pRemDist);
}


} // End namespace for the UA information model http://opcfoundation.org/UA/CNC/

