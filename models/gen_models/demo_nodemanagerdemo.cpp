/******************************************************************************
** demo_nodemanagerdemo.cpp
**
**   **************************** auto-generated ****************************
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.5.0, using C++ OPC UA SDK 1.5.0 template (version 4)
**
**     This is a template file that was generated for your convenience.
**     This file will not be overwritten when generating code again.
**     ADD YOUR IMPLEMTATION HERE!
**   **************************** auto-generated ****************************
**
** Copyright (c) 2006-2016 Unified Automation GmbH. All rights reserved.
**
** Software License Agreement ("SLA") Version 2.5
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.5, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.5/
**
** Project: C++ OPC Server SDK information model for namespace http://cs.hs-rm.de/mierswa_thesis/3AchsenEMCNCLaserSchneid/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** Created: 19.08.2016
**
******************************************************************************/

#include "demo_nodemanagerdemo.h"
#include "nodemanagerroot.h"
#include "opcua_analogitemtype.h"
#include "opcua_dataitemtype.h"
#include "opcua_propertytype.h"
#include "opcuacnc_nodemanagercnc.h"
#include "userdatabase.h"

#include <cstring>

#undef snprintf

#ifdef WIN32
#define snprintf sprintf_s
#else
#define snprintf std::snprintf
#endif

// Include type headers

namespace
{

struct NodeUserData
	: UserDataBase
{
	NodeUserData(const adapter::xml_node_type *node);

	const adapter::xml_node_type *node;
};

struct Browse
{
	Browse(OpcUa_NodeId *node_id, OpcUa_UInt32 node_class_mask, OpcUa_UInt32 browse_mask);
	~Browse();

	UaStatus browse(NodeManagerRoot *nm);
	inline UaReferenceDescriptions &results();

private:
	ServiceContext service_context_;
	std::unique_ptr<BrowseContext> browse_context_;
	std::unique_ptr<OpcUa_ViewDescription> view_description_;
	std::unique_ptr<OpcUa_NodeId> reference_node_id_;
	UaReferenceDescriptions reference_descriptions_;
};

inline UaReferenceDescriptions &Browse::results()
{
	return reference_descriptions_;
}

}

// Namespace for the UA information model http://cs.hs-rm.de/mierswa_thesis/3AchsenEMCNCLaserSchneid/
namespace Demo {

/** Construction of the class NodeManagerDemo.
 */
NodeManagerDemo::NodeManagerDemo(
    std::shared_ptr<adapter::adapter> adapter,
    OpcUa_Boolean firesEvents,  //!< [in] Flag indicating if the NodeManager should activate the EventManager
    OpcUa_Int32 nHashTableSize) //!< [in] Size of the hash table. The default value is 10.007.<br>
                                //   The size can be smaller than the total number of nodes managed
                                //   by the node manager but it is better for the performance to avoid
                                //   collisions with a large size.
                                //   Prefered sizes are 1.009, 10.007, 100.003, 1.000.003, 10.000.019.
: NodeManagerDemoBase(firesEvents, nHashTableSize),
  adapter_(adapter),
  root_nm_(NodeManagerRoot::CreateRootNodeManager())
{
}

/** Destroys the NodeManagerDemo object and all nodes managed by the node manager
 */
NodeManagerDemo::~NodeManagerDemo()
{
}

/** Finish start up in derived class after starting up base class.
 */
UaStatus NodeManagerDemo::afterStartUp()
{
	// The address space is created by the base class
	UaStatus ret = NodeManagerDemoBase::afterStartUp();

	if (!ret.isGood()) {
		return ret;
	}

	OpcUa_NodeId start_node;
	start_node.IdentifierType = OpcUa_IdentifierType_Numeric;
	start_node.NamespaceIndex = 0;
	start_node.Identifier.Numeric = OpcUaId_RootFolder;

	adapter::xml_node_browse_path empty_browse_path;

	check_objects_and_variables(&start_node, empty_browse_path);

	// verify that all nodes specified in XML have been set up
	auto verify_setup = [this](adapter::xml_node_type const &passed_node) {
		if (nodes_.find(&passed_node) == nodes_.end()) {
			char exception_string[1024];
			snprintf(exception_string, sizeof exception_string, "Node <%s> not present in address space.", passed_node.browse_path.str().c_str());
			throw std::runtime_error(exception_string);
		}

		return true;
	};

	adapter_->iterate_nodes(verify_setup);

	// add general model change event to object types
	std::function<void(OpcUa_NodeId *, adapter::xml_node_browse_path const &)> add_missing;

	add_missing = [this, &add_missing](OpcUa_NodeId *node, adapter::xml_node_browse_path const &current_prefix) {
		const OpcUa_UInt32 node_class_mask = OpcUa_NodeClass_ObjectType | OpcUa_NodeClass_Object;
		const OpcUa_UInt32 browse_mask = OpcUa_BrowseResultMask_BrowseName; //OpcUa_BrowseResultMask_TypeDefinition | OpcUa_BrowseResultMask_BrowseName;
		Browse browse(node, node_class_mask, browse_mask);

		UaStatus result = browse.browse(root_nm_);

		if (!result.isGood()) {
			return;
		}

		const OpcUa_UInt16 cnc_namespace = OpcUaCnc::NodeManagerCNC::getTypeNamespace();

		for (OpcUa_UInt32 i = 0; i < browse.results().length(); i++) {
			OpcUa_ReferenceDescription *current = &browse.results()[i];
			OpcUa_NodeId *child_node = &current->NodeId.NodeId;
			const OpcUa_UInt16 definition_ns_idx = current->TypeDefinition.NodeId.NamespaceIndex;
			const OpcUa_UInt32 definition_id = current->TypeDefinition.NodeId.Identifier.Numeric;

			UaString ua_ns_uri;
			result = root_nm_->getNamespaceUriFromIndex(current->BrowseName.NamespaceIndex, ua_ns_uri);

			if (!result.isGood()) {
				throw std::runtime_error("Unable to find namespace URI.");
			}

			// the variable is reference counted, check exceptions
			UaNode *ua_child_node = root_nm_->getNode(*child_node);

			if (ua_child_node == NULL) {
				throw std::runtime_error("Can't fetch node while browsing.");
			}

			adapter::xml_node_browse_path new_browse_path = current_prefix;

			try {
				const char *raw_browse_name = OpcUa_String_GetRawString(&(current->BrowseName.Name));
				const adapter::xml_node_browse_name new_browse_name = { ua_ns_uri.toUtf8(), raw_browse_name };
				new_browse_path.elements.push_back(new_browse_name);

				const OpcUa_UInt16 ns_idx = current->BrowseName.NamespaceIndex;
				const OpcUa_UInt32 id = current->NodeId.NodeId.Identifier.Numeric;

				if (ns_idx == cnc_namespace) {
					switch (id) {
						case OpcUaCncId_CncAxisListType:
						case OpcUaCncId_CncChannelListType:
						case OpcUaCncId_CncSpindleListType:
							add_general_model_change_event(ua_child_node);
							break;
					}
				}
			} catch (...) {
				ua_child_node->releaseReference();
				throw;
			}

			add_missing(child_node, new_browse_path);
		}
	};

	start_node.Identifier.Numeric = OpcUaId_TypesFolder;
	add_missing(&start_node, empty_browse_path);

	start();

	// Add custom start up code here
	return ret;
}

void NodeManagerDemo::add_general_model_change_event(UaNode *node)
{
	const UaStatus result = addUaReference(node->nodeId(), OpcUaId_GeneralModelChangeEventType, OpcUaId_GeneratesEvent);

	if (!result.isGood()) {
		throw std::runtime_error("Unable to add GeneralModelChangeEventType reference to some nodes.");
	}
}

void NodeManagerDemo::check_objects_and_variables(OpcUa_NodeId *start_node, adapter::xml_node_browse_path const &current_prefix)
{
	const OpcUa_UInt32 node_class_mask = OpcUa_NodeClass_Object | OpcUa_NodeClass_Variable;
	const OpcUa_UInt32 browse_mask = OpcUa_BrowseResultMask_TypeDefinition | OpcUa_BrowseResultMask_BrowseName;
	Browse browse(start_node, node_class_mask, browse_mask);

	UaStatus result = browse.browse(root_nm_);

	if (!result.isGood()) {
		return;
	}

	const OpcUa_UInt16 cnc_namespace = OpcUaCnc::NodeManagerCNC::getTypeNamespace();

	for (OpcUa_UInt32 i = 0; i < browse.results().length(); i++) {
		OpcUa_ReferenceDescription *current = &browse.results()[i];
		const OpcUa_UInt16 definition_ns_idx = current->TypeDefinition.NodeId.NamespaceIndex;
		const OpcUa_UInt32 definition_id = current->TypeDefinition.NodeId.Identifier.Numeric;

		// not allowed to browse server
		if (definition_ns_idx == 0 && definition_id == OpcUaId_ServerType) {
			continue;
		}

		OpcUa_NodeId *child_node = &current->NodeId.NodeId;

		//const std::string ns_uri = OpcUa_String_GetRawString(&refDescs[i].NodeId.NamespaceUri);
		UaString ua_ns_uri;
		result = root_nm_->getNamespaceUriFromIndex(current->BrowseName.NamespaceIndex, ua_ns_uri);

		if (!result.isGood()) {
			throw std::runtime_error("Unable to find namespace URI.");
		}

		adapter::xml_node_browse_path new_browse_path = current_prefix;

		// the variable is reference counted, check exceptions
		UaNode *ua_child_node = root_nm_->getNode(*child_node);

		if (ua_child_node == NULL) {
			throw std::runtime_error("Can't fetch node while browsing.");
		}

		try {
			const char *raw_browse_name = OpcUa_String_GetRawString(&(current->BrowseName.Name));
			const adapter::xml_node_browse_name new_browse_name = { ua_ns_uri.toUtf8(), raw_browse_name };
			new_browse_path.elements.push_back(new_browse_name);


			if (definition_ns_idx == cnc_namespace) {
				switch (definition_id) {
					case OpcUaCncId_CncAxisListType:
					case OpcUaCncId_CncChannelListType:
					case OpcUaCncId_CncSpindleListType:
						add_general_model_change_event(ua_child_node);
						break;
				}
			}

			adapter_->iterate_nodes([this, ua_child_node, &new_browse_path](adapter::xml_node_type const &passed_node) {
				if (passed_node.browse_path == new_browse_path) {
					if (nodes_.find(&passed_node) != nodes_.end()) {
						throw std::runtime_error("Duplicate node.");
					}

					nodes_[&passed_node] = *(ua_child_node->nodeId());

					try {
						setup_node(passed_node, ua_child_node);
					} catch (std::exception const &) {
						nodes_.erase(nodes_.find(&passed_node));
						throw;
					}

					return false;
				}

				return true;
			});
		} catch (...) {
			ua_child_node->releaseReference();
			throw;
		}

		check_objects_and_variables(child_node, new_browse_path);
	}
}

/** Start shut down in derived class before shutting down base class.
*/
UaStatus NodeManagerDemo::beforeShutDown()
{
    UaStatus ret;
    return ret;
}

void NodeManagerDemo::setup_node(adapter::xml_node_type const &node, UaNode *ua_node)
{
	ua_node->setUserData(new NodeUserData(&node));

	if (node.name == "variable") {
		UaVariable *ua_var;

		try {
			ua_var = dynamic_cast<UaVariable *>(ua_node);
		} catch (std::bad_cast const &) {
			char exception_string[1024];
			snprintf(exception_string, sizeof exception_string, "Node <%s> is not a variable in address space.", node.browse_path.str().c_str());
			throw std::runtime_error(exception_string);
		}

		std::unique_ptr<adapter::xml_node_type> value_node;

		try {
			value_node.reset(new adapter::xml_node_type(node.children.at("value")[0]));
		} catch (std::out_of_range const &) {
			char exception_string[1024];
			snprintf(exception_string, sizeof exception_string, "Node <%s> is missing value child node.", node.browse_path.str().c_str());
			throw std::runtime_error(exception_string);
		}

		std::string kind;

		try {
			kind = value_node->attributes.at("kind");
		} catch (std::out_of_range const &) {
			char exception_string[1024];
			snprintf(exception_string, sizeof exception_string, "Node <%s> is missing kind attribute in value.", node.browse_path.str().c_str());
			throw std::runtime_error(exception_string);
		}

		if (kind == "fix") {
			if (value_node->value.empty()) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> has empty fixed value.", node.browse_path.str().c_str());
				throw std::runtime_error(exception_string);
			}
		}

		if (ua_var->typeDefinitionId() == OpcUaId_DataItemType) {
			OpcUa::DataItemType *di_var = dynamic_cast<OpcUa::DataItemType *>(ua_var);
			// could set value precision here
		} else if (ua_var->typeDefinitionId() == OpcUaId_PropertyType) {
			OpcUa::PropertyType *p_var = dynamic_cast<OpcUa::PropertyType *>(ua_var);
			// nothing can be added for property types
		} else if (ua_var->typeDefinitionId() == OpcUaId_AnalogItemType) {
			OpcUa::AnalogItemType *ai_var = dynamic_cast<OpcUa::AnalogItemType *>(ua_var);

			std::string unit;
			std::string range_start;
			std::string range_end;

			try {
				unit = value_node->attributes.at("unit");
				range_start = value_node->attributes.at("range_start");
				range_end = value_node->attributes.at("range_end");
			} catch (std::out_of_range const &) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> is missing attributes for AnalogItemType.", node.browse_path.str().c_str());
				throw std::runtime_error(exception_string);
			}

			ai_var->setEURange(UaRange(std::stod(range_start), std::stod(range_end)));

			UaEUInformation unit_info;

			if (unit == "mm/min") {
				unit_info = UaEUInformation::fromUnitId(UaEUInformation::EngineeringUnit_millimetre_per_minute);
			} else if (unit == "mm") {
				unit_info = UaEUInformation::fromUnitId(UaEUInformation::EngineeringUnit_millimetre);
			} else if (unit == "%") {
				unit_info = UaEUInformation::fromUnitId(UaEUInformation::EngineeringUnit_percent);
			} else {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> unit <%s> cannot be setup in UA server.", node.browse_path.str().c_str(), unit.c_str());
				throw std::runtime_error(exception_string);
			}

			ai_var->setEngineeringUnits(unit_info);
		} else {

			std::printf("Node <%s> has unknown data type <%s>.", node.browse_path.str().c_str(), ua_var->dataType().toFullString().toUtf8());
		}

		if (kind == "fix") {
			const UaNodeId data_type = ua_var->dataType();
			UaVariant variant;
			bool value_converted = true;

			if (data_type.namespaceIndex() == 0) {
				if (data_type.identifierNumeric() == OpcUaType_String) {
					variant.setString(value_node->value.c_str());
				} else if (data_type.identifierNumeric() == OpcUaType_Double) {
					variant.setDouble(std::stod(value_node->value));
				} else if (data_type.identifierNumeric() == OpcUaType_UInt32) {
					variant.setUInt32(static_cast<std::uint32_t>(std::stoi(value_node->value)));
				} else {
					value_converted = false;
				}
			} else {
				value_converted = false;
			}

			if (!value_converted) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> has unknown conversion for fix value <%s>", node.browse_path.str().c_str(), data_type.toFullString().toUtf8());
				throw std::runtime_error(exception_string);
			}
		} else if (kind == "fetcher") {
			std::string updated;

			try {
				updated = value_node->attributes.at("updated");
			} catch (std::out_of_range const &) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> is missing updated attribute in value.", node.browse_path.str().c_str());
				throw std::runtime_error(exception_string);
			}

			if (updated == "interval") {
				auto callback = [this, ua_var](adapter::xml_node_type const &passed_node, adapter::xml_node_fetch_info_type const &fetch_info) {
					set_variable_from_node(passed_node, ua_var, fetch_info);
				};

				adapter_->watch_node(node, callback);
			} else {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> has unknown updated attribute in value.", node.browse_path.str().c_str());
				throw std::runtime_error(exception_string);
			}
		} else if (kind == "mirror") {
			std::string mirrored_browse_path;
			adapter::xml_node_type const *mirrored_node = NULL;

			try {
				mirrored_browse_path = value_node->attributes.at("browse_path");
			} catch (std::out_of_range const &) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> is missing browse_path attribute in value.", node.browse_path.str().c_str());
				throw std::runtime_error(exception_string);
			}

			auto callback = [&mirrored_node, &mirrored_browse_path](adapter::xml_node_type const &passed_node) {
				if (passed_node.browse_path.str() == mirrored_browse_path) {
					mirrored_node = &passed_node;
				}
			};

			if (mirrored_node == NULL) {
				char exception_string[1024];
				snprintf(exception_string, sizeof exception_string, "Node <%s> cannot be mirrored because <%s> is not setup.", node.browse_path.str().c_str(), mirrored_browse_path.c_str());
				throw std::runtime_error(exception_string);
			}

			std::printf("Node <%s> is mirrored to <%s>.\n", node.browse_path.str().c_str(), mirrored_browse_path.c_str());	
			mirrored_nodes_[mirrored_node] = &node;
		} else {
			char exception_string[1024];
			snprintf(exception_string, sizeof exception_string, "Node <%s> has unknown updated attribute in value.", node.browse_path.str().c_str());
			throw std::runtime_error(exception_string);
		}

		ua_var->setValueHandling(UaVariable_Value_CacheIsSource);
	} else {
		UaObject *ua_obj = dynamic_cast<UaObject *>(ua_node);
	}

	std::printf("Node <%s> is set up.\n", node.browse_path.str().c_str());
}

namespace
{

template <class E>
void create_ua_variable(std::uint8_t const *& data_position, E &element);

template <class T>
void set_ua_array(T &array, UaVariant &variant);

template <class T>
void assign_ua_array(std::uint8_t const *& data_position, UaVariant &variant)
{
	std::uint32_t size;
	std::memcpy(&size, data_position, 4);

	T array;

	array.resize(size);

	data_position += 4;

	for (std::uint32_t i = 0; i < size; i++) {
		create_ua_variable(data_position, array[i]);
	}

	set_ua_array(array, variant);
}


template <>
void set_ua_array(UaStringArray &array, UaVariant &variant)
{
	variant.setStringArray(array);
}

template <>
void set_ua_array(UaUInt32Array &array, UaVariant &variant)
{
	variant.setUInt32Array(array);
}

template <>
void set_ua_array(UaDoubleArray &array, UaVariant &variant)
{
	variant.setDoubleArray(array);
}

template <class T>
void set_ua_variable(T &variable, UaVariant &variant);


template <class T>
void assign_ua_variable(std::uint8_t const *& data_position, UaVariant &variant)
{
	T variable;
	create_ua_variable(data_position, variable);

	set_ua_variable(variable, variant);
}

template <>
void set_ua_variable(OpcUa_String &variable, UaVariant &variant)
{
	variant.setString(variable);
}

template <>
void set_ua_variable(OpcUa_UInt32 &variable, UaVariant &variant)
{
	variant.setUInt32(variable);
}

template <>
void set_ua_variable(OpcUa_Double &variable, UaVariant &variant)
{
	variant.setDouble(variable);
}

template <>
void create_ua_variable(std::uint8_t const *& data_position, OpcUa_String &string)
{
	std::uint32_t string_size;

	std::memcpy(&string_size, data_position, 4);
	const std::string temp_string(data_position + 4, data_position + 4 + string_size);

	data_position += 4 + string_size;

	UaString temp_ua_string(temp_string.c_str());
	temp_ua_string.copyTo(&string);
}

template <>
void create_ua_variable(std::uint8_t const *& data_position, OpcUa_UInt32 &element)
{
	std::uint32_t integer;
	std::memcpy(&integer, data_position, 4);

	data_position += 4;

	element = integer;
}

template <>
void create_ua_variable(std::uint8_t const *& data_position, OpcUa_Double &element)
{
	std::uint32_t double_string_size;

	std::memcpy(&double_string_size, data_position, 4);

	data_position += 4;

	const std::string double_string(data_position, data_position + double_string_size);

	data_position += double_string_size;

	element = std::stod(double_string);
}

}

void NodeManagerDemo::set_variable_from_node(adapter::xml_node_type const &node, UaVariable *variable, adapter::xml_node_fetch_info_type const &fetch_info)
{
	UaVariant variant;
	const UaNodeId data_type = variable->dataType();
	std::vector<std::uint8_t> const &bytes = fetch_info.bytes;
	std::uint8_t const *data_position = bytes.data();

	bool converted = true;
	const OpcUa_Int32 rank = variable->valueRank();

	if (rank == 1) {
		switch (data_type.identifierNumeric()) {
			case OpcUaId_String: assign_ua_array<UaStringArray>(data_position, variant); break;
			case OpcUaId_UInt32: assign_ua_array<UaUInt32Array>(data_position, variant); break;
			case OpcUaId_Double: assign_ua_array<UaDoubleArray>(data_position, variant); break;
			default: converted = false; break;
		}
	} else if (rank == -1) {
		switch (data_type.identifierNumeric()) {
			case OpcUaCncId_CncOperationMode: {
				std::uint8_t operation_mode = data_position[0];
std::printf("operation mode: %d\n", operation_mode);
				variant.setInt32(data_position[0]);
				break;
			}
			case OpcUaId_String: assign_ua_variable<OpcUa_String>(data_position, variant); break;
			case OpcUaId_UInt32: assign_ua_variable<OpcUa_UInt32>(data_position, variant); break;
			case OpcUaId_Double: assign_ua_variable<OpcUa_Double>(data_position, variant); break;
			default: converted = false; break;
		}
	} else {
		converted = false;
	}

	if (!converted) {
		char exception_string[1024];
		snprintf(exception_string, sizeof exception_string, "Node <%s> value cannot be converted [Rank: %d, Datatype: %u].", node.browse_path.str().c_str(), rank, data_type.identifierNumeric());
 		throw std::runtime_error(exception_string);
	}


	UaDataValue data_value;
	data_value.setValue(variant, OpcUa_True, OpcUa_True);

	variable->setValue(NULL, data_value, OpcUa_False);

	printf("setting variable from node: %s\n", node.browse_path.str().c_str());
	
}

void NodeManagerDemo::run()
{
	adapter_->run();
}

} // End namespace for the UA information model http://cs.hs-rm.de/mierswa_thesis/3AchsenEMCNCLaserSchneid/

namespace
{

NodeUserData::NodeUserData(const adapter::xml_node_type *passed_node)
	: node(passed_node)
{
}

Browse::Browse(OpcUa_NodeId *node_id, OpcUa_UInt32 node_class_mask, OpcUa_UInt32 browse_mask)
	: view_description_(new OpcUa_ViewDescription),
	  reference_node_id_(new OpcUa_NodeId)
{
	OpcUa_ViewDescription_Initialize(view_description_.get());

	reference_node_id_->IdentifierType = OpcUa_IdentifierType_Numeric;
	reference_node_id_->NamespaceIndex = 0;
	reference_node_id_->Identifier.Numeric = OpcUaId_HierarchicalReferences;

	browse_context_.reset(new BrowseContext(view_description_.get(), node_id, 0,
	                                        OpcUa_BrowseDirection_Forward, reference_node_id_.get(),
                                                OpcUa_True, node_class_mask, browse_mask));
}

Browse::~Browse()
{
	browse_context_.reset();
}

UaStatus Browse::browse(NodeManagerRoot *nm)
{
	return nm->browse(service_context_, *browse_context_, reference_descriptions_);
}

}
